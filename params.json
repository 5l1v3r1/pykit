{"name":"Pykit","tagline":"Backend compiler for high-level typed code with first-class support for multi-dimensional arrays, objects and complex numbers.","body":"pykit\r\n=====\r\n\r\nBackend compiler for high-level typed code with first-class support for\r\nmulti-dimensional arrays, objects, complex numbers, list tuples and dicts,\r\nhigher-order functions and sum/union-types.\r\n\r\nPykit tries to address an ever-growing number of compilers in the Python\r\ncommunity, with a focus on array-oriented numerical code.\r\n\r\npykit:\r\n\r\n    * lowers and optimizes intermediate code\r\n    * produces IR that can be mapped to any desired runtime\r\n    * tries to be independent from platform or high-level language\r\n    * can generate LLVM or C89 out of the box\r\n\r\npykit is inspired by VMKit and LLVM.\r\n\r\n---------------------\r\n---------------------\r\n\r\n% Pykit pipeline\r\n% \r\n% \r\n\r\nThe input to pykit is a typed program in the form of a Module,\r\nconsisting of a set of functions, global variables and external symbols.\r\n\r\nThe functions within the module go through successive transformations or\r\nstages defined by the pipeline. We can categorize stages as follows\r\n(similar to parakeet):\r\n\r\n> -   High-level optimizations and analyses\r\n> -   Lowering and scalarization\r\n> -   Codegen\r\n\r\nEvery stage in the pipeline is optional. The order is configurable.\r\nEntire stages can be skipped or overridden.\r\n\r\nHigh-level Optimizations and Analyses\r\n=====================================\r\n\r\nTransformations:\r\n\r\n> -   SSA/mem2reg\r\n> -   Transform unary/binary operations on arrays to map\r\n> -   fusion of map/reduce/scan\r\n\r\nOptimizations and analyses include:\r\n\r\n> -   (sparse conditional) constant propagation\r\n> -   Container vectorization (`list_append -> map`)\r\n> -   Purity analysis\r\n> -   Escape analysis\r\n> -   Partial redundancy elimination\r\n> -   Scalar replacement\r\n> -   Bounds check, wrap around, None check elimination\r\n> -   Optimize cell variables with static binding\r\n> -   Loop fusion (temporary elimination)\r\n> -   Inlining\r\n> -   Exception analysis\r\n\r\nWe need to perform these analyses on high-level code, since subsequent\r\nlowering transformations will reduce or preclude the effectiveness.\r\n\r\nFor example optimizations pykit should do, see :ref:\\`optimizations\\`.\r\n\r\nLowering and Specialization\r\n===========================\r\n\r\nThese stages specialize to a type representation and a runtime. Default\r\nstages lower to a provided pykit :ref:\\`runtime\\`.\r\n\r\n> -   Scalarization `map -> for`\r\n> -   Expand sum type operations\r\n> -   Data and object allocation (based on escape analysis)\r\n> -   Lower container operations\r\n> -   Lower Thread API into runtime calls\r\n> -   Lower cell variable allocation and storage/loading\r\n> -   Lower type conversion...\r\n>\r\n>     > -   Internal representation\r\n>     > -   CPython C API\r\n>\r\n> -   Lower object operations\r\n>\r\n>     > -   CPython C API\r\n>     > -   Some user pass\r\n>     > -   Error\r\n>\r\n> -   Lower virtual method calls / virtual attribute access\r\n>\r\n>     > -   Actual vtable lookup should be deferred to a user provided\r\n>     >     pass\r\n>\r\n> -   Refcounting or GC pass\r\n> -   Lower exception handling code\r\n>\r\n>     > -   zero cost\r\n>     > -   setjmp/longjump\r\n>     > -   error return codes\r\n>\r\nCodegen\r\n=======\r\n\r\nThe code is in a low-level format by now, and can be easily used to\r\ngenerate code from. We are left with:\r\n\r\n> -   Scalars operations (int, float, pointer, function)\r\n> -   Aggregate accesses (struct, union)\r\n> -   Scalar conversions and pointer casts\r\n> -   Memory operations (load, store)\r\n> -   Control flow (branch, conditional branch, return, exceptions)\r\n> -   Function calls\r\n> -   phi\r\n> -   Constants\r\n% Pykit Runtime\r\n% \r\n% \r\n\r\nPykit comes with a default runtime, that supports the following:\r\n\r\n> -   Boxed structures with an internal format\r\n>\r\n>     > -   (atomically) reference counted or GCed\r\n>\r\n> -   Conversion between internal representations and Python objects\r\n> -   A portable thread API\r\n> -   A memory allocator\r\n>\r\nAll these parts are optional and can be ignored. For instance one can\r\ndisallow dynamic memory allocation, or provide a different\r\nimplementation simply by writing a different lowering pass or linking\r\nwith a different library exposing the same API.\r\n% Example Optimizations\r\n% \r\n% \r\n\r\nWhat follows are some example transformations pykit should be able to\r\nhandle in the future.\r\n\r\nAggregates\r\n==========\r\n\r\nStack allocation:\r\n\r\n```python\r\nt = x, y, z # escape = { 't': [] }\r\n# --> (struct converion and stack allocation)\r\nt = new_struct(x, y, z) # stack allocation through escape info\r\n```\r\n\r\n* * * * *\r\n\r\nStack allocation + Inlining:\r\n\r\n```python\r\ndef f(x, y):\r\n    t = g(x), g(y) # escape = { 't': ['return'] }\r\n    return t\r\n\r\nx, y = f(1, 2)\r\n\r\n# --> (struct conversion)\r\n\r\ndef f(x, y):\r\n    t = new_struct(g(x), g(y)) # escape = { 't': ['return'] }\r\n    return t                   # inlining beneficial to remove temporary\r\n\r\nx, y = f(1, 2)\r\n\r\n# --> (inlining)\r\n\r\nt = new_struct(g(1), g(2))\r\nx, y = t\r\n\r\n# --> (redundancy elimination)\r\n\r\nx = g(1)\r\ny = g(2)\r\n```\r\n\r\nArrays\r\n======\r\n\r\nElement-wise:\r\n\r\n```python\r\nresult = A + B * C\r\n# -->\r\nmap(add, A, map(mul, B, C))\r\n# --> (fusion)\r\nmap(composed_add_mul, A, B, C)\r\n# -> map(fma, A, B, C) -- llvm will figure this out\r\n```\r\n\r\n* * * * *\r\n\r\nReductions:\r\n\r\n```python\r\nreduce(add, A + B)\r\n# -->\r\nreduce(add, map(add, A, B))\r\n# -->\r\nreduce(add_add, [A, B])\r\n```\r\n\r\n* * * * *\r\n\r\nParallelism:\r\n\r\n```python\r\nmap(pure_function, A)\r\n# -->\r\nparallel_map(pure_function, A)\r\n```\r\n\r\n* * * * *\r\n\r\nOrder specialization:\r\n\r\n```python\r\nA = ... # order = C\r\nB = ... # order = F\r\nA + B\r\n# -->\r\ntiled_map(add, A, B)\r\n```\r\n\r\n* * * * *\r\n\r\nMKL:\r\n\r\n```python\r\nsqrt(A)\r\n# -->\r\nmap(sqrt, A)\r\n# -->\r\nmap(vsSqrt, A[:, ::blocksize])\r\n```\r\n\r\n* * * * *\r\n\r\nBounds checking:\r\n\r\n```python\r\ndef swap(A, i):\r\n    t        = A[i]\r\n    A[i]     = A[i + 1]\r\n    A[i + 1] = t\r\n\r\n# --> (add bounds checking)\r\n\r\ndef swap(A, i):\r\n    assert 0 <= i < A.shape[0]\r\n    t        = A[i]\r\n    assert 0 <= i + 1 < A.shape[0]\r\n    assert 0 <= i < A.shape[0]\r\n    A[i]     = A[i + 1]\r\n    assert 0 <= i + 1 < A.shape[0]\r\n    A[i + 1] = t\r\n\r\n# --> (elimination)\r\n\r\ndef swap(A, i):\r\n    assert 0 <= i\r\n    assert i + 1 < A.shape[0]\r\n    t        = A[i]\r\n    A[i]     = A[i + 1]\r\n    A[i + 1] = t\r\n```\r\n\r\n* * * * *\r\n\r\nWrap-around elimination:\r\n\r\n```python\r\ndef swap(A, i):\r\n    t        = A[i]\r\n    A[i]     = A[i + 1]\r\n    A[i + 1] = t\r\n\r\n# --> (add wrap around)\r\n\r\ndef swap(A, i):\r\n    idx0 = i if i >= 0 else i + A.shape[0]\r\n    t = A[idx0]\r\n\r\n    idx1 = i + 1if i + 1 >= 0 else i + 1 + A.shape[0]\r\n    idx2 = i if i >= 0 else i + A.shape[0]\r\n    A[idx2] = A[idx1]\r\n\r\n    idx1 = i + 1 if i + 1 >= 0 else i + 1 + A.shape[0]\r\n    A[i + 1] = t\r\n\r\n# --> (elimination)\r\n\r\ndef swap(A, i):\r\n    idx0 = i if i >= 0 else i + A.shape[0]\r\n    idx1 = i + 1 if i + 1 >= 0 else i + 1 + A.shape[0]\r\n    t = A[idx0]\r\n    A[idx0] = A[idx1]\r\n    A[idx1] = t\r\n```\r\n\r\nContainers\r\n==========\r\n\r\nList loop fusion:\r\n\r\n```python\r\nL = []\r\nfor i in range(10):\r\n    L.append(i*i)\r\nfor x in L:\r\n    use(x)\r\n\r\n# --> (vectorize)\r\n\r\nL = map(square, range(10))  # lazy=True since square is pure\r\nfor x in L:\r\n    use(x)\r\n\r\n# --> (fusion)\r\n\r\nfor i in range(10):\r\n    x = i * i\r\n    use(x)\r\n```\r\n\r\nOr perhaps:\r\n\r\n```python\r\nL = []\r\nfor i in range(10):\r\n    L.append(i*i)\r\nfor x in L:\r\n    use(x)\r\n\r\n# --> (vectorize)\r\n\r\nL = map(square, range(10))  # lazy=True, uses=[_]\r\n_ = map(use, L)             # lazy=False, uses=[]\r\n\r\n# --> (fusion)\r\n\r\nmap(compose(use, square), L) # lazy=is_pure(use)\r\n```\r\n\r\n* * * * *\r\n\r\nRedundancy elimination:\r\n\r\n```python\r\nL.append(x)\r\ny = L.pop()\r\n# -->\r\ny = x\r\n```\r\n\r\n* * * * *\r\n\r\nPreallocation:\r\n\r\n```python\r\nL = []\r\nfor i in range(N):\r\n    L.append(...)\r\n\r\n# -->\r\n\r\nL = [] # preallocate = N\r\nfor i in range(N):\r\n    L.append(...)\r\n```\r\n\r\n* * * * *\r\n\r\nList consumption:\r\n\r\n```python\r\nL = [f(x) for x in lst]\r\nwhile L:\r\n    x = L.pop()\r\n    use(x)\r\n\r\n# no further uses of L\r\n\r\n# -->\r\n\r\nL = [f(x) for x in lst]\r\nfor x in reversed(L):\r\n    use(x)\r\n\r\n# --> (if f has no side-effects)\r\n\r\nfor tmp in reversed(lst):\r\n    x = f(tmp)\r\n    use(x)\r\n```\r\n\r\n* * * * *\r\n\r\nInlining and fusion:\r\n\r\n```python\r\ndef split(str, sep):\r\n    result = []\r\n    begin = 0\r\n    end = 0\r\n\r\n    while end < len(str):\r\n        end = find(str, sep, begin)\r\n        if end == -1:\r\n            end = len(str)\r\n        result.append(str[begin:end])\r\n        begin = end + len(sep)\r\n\r\n    return result # escape={'result': ['return'], 'str': ['find', 'len']}\r\n\r\ndef somefunc(str):\r\n    for part in split(str, \" \"): # inlining beneficial to remove temporary\r\n        use(part)\r\n\r\n# --> (inlining)\r\n\r\ndef somefunc(str):\r\n    result = []\r\n    begin = 0\r\n    end = 0\r\n\r\n    while end < len(str):\r\n        end = find(str, sep, begin)\r\n        if end == -1:\r\n            end = len(str)\r\n        result.append(str[begin:end])\r\n        begin = end + len(sep)\r\n\r\n    for part in result:\r\n        use(part)\r\n\r\n# --> (fusion)\r\n\r\ndef somefunc(str):\r\n    result = []\r\n    begin = 0\r\n    end = 0\r\n\r\n    while end < len(str):\r\n        end = find(str, sep, begin)\r\n        if end == -1:\r\n            end = len(str)\r\n        tmp = str[begin:end]\r\n        begin = end + len(sep)\r\n\r\n        part = tmp\r\n        use(part)\r\n```\r\n\r\n* * * * *\r\n% FAQ\r\n% \r\n% \r\n\r\nWhy this project?\r\n=================\r\n\r\nThe motivation for this project is an ever growing number of compilers\r\nfor Python out there. Pykit tries to provide a higher-level layer than\r\nLLVM or C for typed Python code, focussing on numeric code, so that\r\noptimizations and runtime improvements benefit everyone.\r\n\r\nIt aims to be reusable for projects including:\r\n\r\n> -   Numba\r\n> -   Parakeet\r\n> -   Pythran\r\n> -   Theano\r\n> -   NumbaPro\r\n> -   Your next awesome compiler\r\n\r\nIf something in pykit somehow precludes reuse in any of the above\r\nprojects, then pykit has failed and we need to fix that.\r\n\r\nWhy not LLVM IR?\r\n================\r\n\r\nWhy not directly use LLVM IR for the internal format? There are pros and\r\ncons to doing that, below are some reasons why not to:\r\n\r\n> -   Completeness, we can encode all high-level constructs directly in\r\n>     the way we wish, without naming schemes, LLVM metadata, or\r\n>     external data\r\n> -   Instruction polymorphism the way we want it\r\n> -   High-level types, such as arrays, complex numbers, objects,\r\n>     partial functions etc, without opague type mappings\r\n> -   Simple arbitrary metadata through a key/value mechanism\r\n> -   No aborting, ever","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}